@Kif FILE /Users/mac/Documents/other_miscellaneous_projects/kif_diff/kif.py
@Kif SEARCH_AND_REPLACE
@Kif BEFORE
#### SEARCH_AND_REPLACE Parameters

**`replace_all`** (boolean, default: `false`)
- When `true`, replaces all occurrences of the BEFORE block
- When `false`, replaces only the first occurrence

**`ignore_whitespace`** (boolean, default: `false`)
- When `true`, ignores trailing whitespace on each line when matching
- Useful when editors auto-trim whitespace

**`fuzzy_match`** (boolean, default: `false`)
- When `true`, uses fuzzy matching to find similar content
- Reserved for future implementation

**`regex`** (boolean, default: `false`)
- When `true`, treats the BEFORE block as a regular expression pattern
- When `false`, treats the BEFORE block as literal text
- Useful for pattern matching and replacement
@Kif END_BEFORE
@Kif AFTER
#### SEARCH_AND_REPLACE Parameters

**`replace_all`** (boolean, default: `false`)
- When `true`, replaces all occurrences of the BEFORE block
- When `false`, replaces only the first occurrence
- **Important**: Even when using regex, `replace_all=true` is required to replace all matches. Without it, only the first regex match will be replaced.

**`count`** (integer, default: `1`)
- Specifies the exact number of occurrences to replace
- Only takes effect when `replace_all` is `false`
- Cannot be used together with `replace_all=true` (replace_all takes priority)
- Useful when you want to replace a specific number of occurrences but not all

**`ignore_whitespace`** (boolean, default: `false`)
- When `true`, ignores trailing whitespace on each line when matching
- Useful when editors auto-trim whitespace

**`fuzzy_match`** (boolean, default: `false`)
- When `true`, uses fuzzy matching to find similar content
- Reserved for future implementation

**`regex`** (boolean, default: `false`)
- When `true`, treats the BEFORE block as a regular expression pattern
- When `false`, treats the BEFORE block as literal text
- Useful for pattern matching and replacement
@Kif END_AFTER
@Kif END_SEARCH_AND_REPLACE

@Kif SEARCH_AND_REPLACE
@Kif BEFORE
    # Get parameters
    replace_all = params.get('replace_all', False)
    ignore_whitespace = params.get('ignore_whitespace', False)
    fuzzy_match = params.get('fuzzy_match', False)
    use_regex = params.get('regex', False)
    
    if args.verbose:
        print(f"  Parameters: replace_all={replace_all}, ignore_whitespace={ignore_whitespace}, regex={use_regex}")
@Kif END_BEFORE
@Kif AFTER
    # Get parameters
    replace_all = params.get('replace_all', False)
    count = params.get('count', 1)
    ignore_whitespace = params.get('ignore_whitespace', False)
    fuzzy_match = params.get('fuzzy_match', False)
    use_regex = params.get('regex', False)
    
    # If replace_all is true, count is ignored
    if replace_all:
        count = None
    
    if args.verbose:
        print(f"  Parameters: replace_all={replace_all}, count={count}, ignore_whitespace={ignore_whitespace}, regex={use_regex}")
@Kif END_AFTER
@Kif END_SEARCH_AND_REPLACE

@Kif SEARCH_AND_REPLACE
@Kif BEFORE
        if args.dry_run:
            print_warning("DRY RUN: Would modify file (no changes made)")
            occurrences = search_content.count(search_before)
            print(f"  Found {occurrences} occurrence(s)")
            if replace_all:
                print(f"  Would replace all {occurrences} occurrence(s)")
            else:
                print("  Would replace first occurrence only")
            stats.skipped += 1
            return
@Kif END_BEFORE
@Kif AFTER
        if args.dry_run:
            print_warning("DRY RUN: Would modify file (no changes made)")
            occurrences = search_content.count(search_before)
            print(f"  Found {occurrences} occurrence(s)")
            if replace_all:
                print(f"  Would replace all {occurrences} occurrence(s)")
            elif count > 1:
                print(f"  Would replace {count} occurrence(s)")
            else:
                print("  Would replace first occurrence only")
            stats.skipped += 1
            return
@Kif END_AFTER
@Kif END_SEARCH_AND_REPLACE

@Kif SEARCH_AND_REPLACE
@Kif BEFORE
        # Perform replacement
        if use_regex:
            if replace_all:
                new_content = pattern.sub(after_text, content)
                if args.verbose:
                    print(f"  Replaced {match_count} occurrence(s) using regex")
            else:
                new_content = pattern.sub(after_text, content, count=1)
                if args.verbose:
                    print("  Replaced first occurrence using regex")
        else:
            if replace_all:
                new_content = content.replace(before_text, after_text)
                if args.verbose:
                    print(f"  Replaced {match_count} occurrence(s)")
            else:
                new_content = content.replace(before_text, after_text, 1)
                if args.verbose:
                    print("  Replaced first occurrence")
@Kif END_BEFORE
@Kif AFTER
        # Perform replacement
        if use_regex:
            if replace_all:
                new_content = pattern.sub(after_text, content)
                if args.verbose:
                    print(f"  Replaced {match_count} occurrence(s) using regex")
            else:
                # Use count parameter (default 1)
                new_content = pattern.sub(after_text, content, count=count)
                if args.verbose:
                    print(f"  Replaced {count} occurrence(s) using regex")
        else:
            if replace_all:
                new_content = content.replace(before_text, after_text)
                if args.verbose:
                    print(f"  Replaced {match_count} occurrence(s)")
            else:
                # For literal text replacement, we need to handle count manually
                if count == 1:
                    new_content = content.replace(before_text, after_text, 1)
                else:
                    # Replace count occurrences manually
                    parts = []
                    remaining = content
                    replaced = 0
                    
                    while replaced < count and before_text in remaining:
                        index = remaining.find(before_text)
                        parts.append(remaining[:index])
                        parts.append(after_text)
                        remaining = remaining[index + len(before_text):]
                        replaced += 1
                    
                    parts.append(remaining)
                    new_content = ''.join(parts)
                
                if args.verbose:
                    print(f"  Replaced {count} occurrence(s)")
@Kif END_AFTER
@Kif END_SEARCH_AND_REPLACE

@Kif SEARCH_AND_REPLACE
@Kif BEFORE
Directive Parameters:
  @Kif SEARCH_AND_REPLACE(replace_all=true, ignore_whitespace=false, regex=true)
  
  Available parameters:
    - replace_all: Replace all occurrences (default: false)
    - ignore_whitespace: Ignore trailing whitespace (default: false)
    - fuzzy_match: Use fuzzy matching (default: false)
    - regex: Use regular expressions for matching (default: false)
@Kif END_BEFORE
@Kif AFTER
Directive Parameters:
  @Kif SEARCH_AND_REPLACE(replace_all=true, count=3, ignore_whitespace=false, regex=true)
  
  Available parameters:
    - replace_all: Replace all occurrences (default: false)
    - count: Replace specific number of occurrences (default: 1)
    - ignore_whitespace: Ignore trailing whitespace (default: false)
    - fuzzy_match: Use fuzzy matching (default: false)
    - regex: Use regular expressions for matching (default: false)
@Kif END_AFTER
@Kif END_SEARCH_AND_REPLACE