KifDiff Instructions for LLMs v3.0

IMPORTANT NOTES:

1. **Comments are supported!** Use # for single-line comments.
   Lines starting with # (outside of content blocks) are ignored by the parser.

   Example:
   ```text
   # This is a comment
   @Kif READ /path/to/file.txt
   # Another comment
   @Kif TREE /path/to/dir
   ```

2. **Directives as content are preserved!**
   When inside BEFORE/AFTER blocks (or CREATE/OVERWRITE_FILE content),
   @Kif directives are treated as literal content, not as directives.
   
   This allows you to use KifDiff on KifDiff files themselves!
   
   Example:
   ```text
   @Kif SEARCH_AND_REPLACE /path/to/file.kifdiff
   @Kif BEFORE
   @Kif READ /old/path.txt
   @Kif END_BEFORE
   @Kif AFTER
   @Kif READ /new/path.txt
   @Kif END_AFTER
   @Kif END_SEARCH_AND_REPLACE
   ```
   
   The @Kif READ directives inside BEFORE/AFTER are treated as content, not directives.

CRITICAL WORKFLOW: Context-Aware Execution

KifDiff can operate in TWO MODES depending on your knowledge of the codebase:

DIRECT EXECUTION MODE (Preferred)
When to use: You already have the file contents from conversation context
Action: Create a .kifdiff file directly with CREATE, DELETE, OVERWRITE_FILE, MOVE, or SEARCH_AND_REPLACE operations
Skip inquiry: No need to ask for file contents you already have

INQUIRY MODE (Only When Needed)
When to use: You DON'T have the file contents or directory structure you need
Action: Create a .kifdiff file with ONLY @Kif READ, @Kif TREE, or @Kif FIND directives
Wait: Get the inquiry results from the user before proceeding with execution

GOLDEN RULE: Only inquire when you lack necessary information!

If the user has already shared file contents, shown you code, or you have the context you need from earlier in the conversation, skip straight to execution. Don't waste time asking for information you already have.

ALWAYS USE CODE BLOCKS
ALL KifDiff content must be wrapped in code blocks. This makes it easy for users to copy and save as .kifdiff files.

Bad Example:
Here's the inquiry file:
@Kif READ lib/example.dart

Good Example:
```text
@Kif READ lib/example.dart
```

Or when you have the context:
```text
@Kif SEARCH_AND_REPLACE /home/user/project/lib/example.dart
@Kif BEFORE
...
@Kif END_BEFORE
@Kif AFTER
...
@Kif END_AFTER
@Kif END_SEARCH_AND_REPLACE
```


=== NEW SYNTAX STRUCTURE ===

All directives now follow this uniform structure:

@Kif <DIRECTIVE_NAME>(<optional_keyword_args>) <required_non_keyword_args>

Examples:
- @Kif CREATE /path/to/file.txt
- @Kif CREATE(backup=false) /path/to/file.txt
- @Kif TREE(depth=2, show_hidden=false) /path/to/directory
- @Kif SEARCH_AND_REPLACE(replace_all=true) /path/to/file.txt
- @Kif FIND(match_pattern=".*\.py$", exclude="__pycache__") /path/to/search


Core Directives

IMPORTANT CHANGE: The @Kif FILE directive has been REMOVED. 
All directives now take file paths directly as required arguments.


INQUIRY Operations (Use Only When Needed)

@Kif READ <absolute_path>
Reads a file's contents and copies it to clipboard (or prints to console).

Use ONLY when you need to:
- Examine code you haven't seen yet
- Understand implementation details not provided in conversation
- Check file structure or dependencies you're unaware of

Example:
@Kif READ /home/user/project/lib/example.dart


@Kif TREE(<parameters>) <absolute_path>
Displays directory structure as a visual tree.

Parameters:
- depth=N - Maximum directory depth (default: unlimited)
- show_hidden=true/false - Include hidden files (default: false)
- include_files=true/false - Show files or only directories (default: true)

Use ONLY when you need to:
- Understand project structure you don't know
- Find related files in unfamiliar directories
- Locate where to create new files when structure is unclear

Examples:
@Kif TREE /home/user/project/lib/

@Kif TREE(depth=2, show_hidden=false) /home/user/project/

@Kif TREE(depth=1, include_files=false) /home/user/project/lib/widgets/


@Kif FIND(<parameters>) <absolute_path>
Finds files in a directory matching regex patterns.

Parameters:
- match_pattern="regex" - Regex pattern for files to match (default: ".*")
- include="regex" - Regex pattern for files to include (optional)
- exclude="regex" - Regex pattern for files to exclude (optional)
- depth=N - Maximum directory depth (default: unlimited)

Use ONLY when you need to:
- Find files by name pattern across directories
- Locate specific file types (e.g., all .py files)
- Search with complex include/exclude criteria

Examples:
Find all Python files:
@Kif FIND(match_pattern=".*\.py$") /home/user/project/

Find TypeScript files, excluding tests:
@Kif FIND(match_pattern=".*\.ts$", exclude=".*\.test\.ts$") /home/user/project/src/

Find all files with "config" in name, max depth 2:
@Kif FIND(match_pattern=".*config.*", depth=2) /home/user/project/


EXECUTION Operations

1. Create File

Creates a new file (overwrites if exists).

Syntax:
@Kif CREATE <absolute_path>
... (file content) ...
@Kif END_CREATE

Important:
- Use absolute paths directly in the CREATE directive
- Creates parent directories automatically if they don't exist
- Overwrites the file if it already exists (automatically backed up)

Example:
@Kif CREATE /home/user/project/lib/constants.dart
class AppConstants {
  static const String appName = 'My Awesome App';
  static const double defaultPadding = 16.0;
}
@Kif END_CREATE


2. Overwrite File

Completely replaces the contents of an existing file (or creates it if it doesn't exist).

Syntax:
@Kif OVERWRITE_FILE <absolute_path>
... (new file content) ...
@Kif END_OVERWRITE_FILE

Important:
- Use absolute paths directly in the OVERWRITE_FILE directive
- Automatically backs up the existing file before overwriting
- Creates the file if it doesn't exist
- More efficient than DELETE + CREATE when replacing most of a file's content

When to use OVERWRITE_FILE vs SEARCH_AND_REPLACE:
- Use OVERWRITE_FILE when replacing more than 80% of a file's content
- Use SEARCH_AND_REPLACE for targeted changes to specific sections

Example:
@Kif OVERWRITE_FILE /home/user/project/lib/config.dart
class Config {
  static const String apiUrl = 'https://api.example.com';
  static const int timeout = 30;
}
@Kif END_OVERWRITE_FILE


3. Delete File

Deletes a file (automatically backed up).

Syntax:
@Kif DELETE <absolute_path>

Example:
@Kif DELETE /home/user/project/lib/old_utils.dart


4. Move/Rename File or Directory

Moves or renames files and directories (automatically backed up).

Syntax:
@Kif MOVE <source_path> <destination_path>

Important:
- Use absolute paths for both source and destination
- Works for both files and directories
- Automatically creates destination directories if they don't exist
- Source file/directory is backed up before moving

Use Cases:
- Rename a file: @Kif MOVE /path/old_name.dart /path/new_name.dart
- Move to different directory: @Kif MOVE /path/file.dart /new/path/file.dart
- Rename and move: @Kif MOVE /old/path/old_name.dart /new/path/new_name.dart
- Move entire directory: @Kif MOVE /old/dir /new/dir

Examples:
Rename a file:
@Kif MOVE /home/user/project/lib/old_utils.dart /home/user/project/lib/new_utils.dart

Move file to different directory:
@Kif MOVE /home/user/project/lib/utils.dart /home/user/project/lib/helpers/utils.dart

Move and rename:
@Kif MOVE /home/user/project/lib/old_name.dart /home/user/project/lib/core/new_name.dart

Move entire directory:
@Kif MOVE /home/user/project/lib/old_widgets /home/user/project/lib/components


5. Search and Replace

Finds and replaces text blocks. Most powerful operation.
NOW SUPPORTS MULTIPLE BEFORE/AFTER BLOCKS IN THE SAME FILE!

Syntax:
@Kif SEARCH_AND_REPLACE(<parameters>) <absolute_path>
@Kif BEFORE
... (exact text to find) ...
@Kif END_BEFORE
@Kif AFTER
... (replacement text) ...
@Kif END_AFTER
@Kif BEFORE
... (another text to find) ...
@Kif END_BEFORE
@Kif AFTER
... (another replacement) ...
@Kif END_AFTER
@Kif END_SEARCH_AND_REPLACE

Parameters:

- replace_all=true/false (default: false)
  true: Replace all occurrences
  false: Replace only first occurrence
  Important: Even with regex, you need replace_all=true to replace all matches

- count=N (default: 1)
  Replace exactly N occurrences
  Only works when replace_all=false
  Useful for replacing specific instances without replacing all

- regex=true/false (default: false)
  true: Treat BEFORE block as regex pattern
  false: Treat BEFORE block as literal text

- ignore_whitespace=true/false (default: false)
  true: Ignore trailing whitespace when matching
  Useful when editors auto-trim whitespace

Critical Rules:
- BEFORE block must match exactly (including whitespace)
- Use absolute paths
- Files are automatically backed up
- Multiple BEFORE/AFTER blocks are processed sequentially
- All blocks share the same parameters

Example - Multiple Replacements in Same File:
@Kif SEARCH_AND_REPLACE /home/user/project/lib/ui_button.dart
@Kif BEFORE
  void onPressed() {
    print('Button pressed');
  }
@Kif END_BEFORE
@Kif AFTER
  void onPressed() {
    print('Button pressed');
    _handleButtonPress();
  }
@Kif END_AFTER
@Kif BEFORE
  final String label = 'Submit';
@Kif END_BEFORE
@Kif AFTER
  final String label = 'Submit Form';
@Kif END_AFTER
@Kif END_SEARCH_AND_REPLACE

Example - Replace All Occurrences:
@Kif SEARCH_AND_REPLACE(replace_all=true) /home/user/project/lib/theme.dart
@Kif BEFORE
Color.blue
@Kif END_BEFORE
@Kif AFTER
Color(0xFF2196F3)
@Kif END_AFTER
@Kif END_SEARCH_AND_REPLACE

Example - Replace Specific Count:
@Kif SEARCH_AND_REPLACE(count=3) /home/user/project/lib/logger.dart
@Kif BEFORE
print(
@Kif END_BEFORE
@Kif AFTER
debugPrint(
@Kif END_AFTER
@Kif END_SEARCH_AND_REPLACE

Example - Using Regex:
@Kif SEARCH_AND_REPLACE(regex=true, replace_all=true) /home/user/project/lib/config.dart
@Kif BEFORE
const int timeout = \d+;
@Kif END_BEFORE
@Kif AFTER
const int timeout = 5000;
@Kif END_AFTER
@Kif END_SEARCH_AND_REPLACE


6. Run Terminal Command

Executes terminal commands with security controls (allowlist/blocklist).

Syntax:
@Kif RUN <command>
@Kif RUN(<parameters>) <command>

Parameters:
- timeout=N (default: 30, max: 300)
  Command timeout in seconds

- shell=true/false (default: true)
  Enable shell mode for command parsing and expansion
  Set to false for direct executable calls (more secure but less flexible)

- cwd="path/to/directory" (default: current directory)
  Working directory where command will execute
  Supports absolute paths and ~ expansion
  IMPORTANT: LLMs should specify this when working in project subdirectories

Security:
- Commands are filtered by patterns in config.py
- Default mode: blocklist (all commands run except blocked ones)
- Always blocks dangerous operations (rm -rf, sudo, etc.)
- Users can customize per-project or globally

Important:
- ALL command output is captured and copied to clipboard (including errors)
- Exit codes are reported (0 = success, non-zero = failure)
- Commands execute in specified working directory (or current directory by default)
- Timeout protection prevents hanging processes
- Shell mode is enabled by default for natural command syntax

Examples:

Basic command:
@Kif RUN git status

With timeout:
@Kif RUN(timeout=60) npm install

With shell expansion:
@Kif RUN(shell=true) echo $PATH

With working directory:
@Kif RUN(cwd="/path/to/project") npm install
@Kif RUN(cwd="~/projects/myapp") flutter pub get

Combined parameters:
@Kif RUN(cwd="/path/to/project", timeout=120, shell=true) npm run build

Multiple commands in sequence:
@Kif RUN(cwd="/path/to/flutter/project") flutter pub get
@Kif RUN(cwd="/path/to/flutter/project") flutter test
@Kif RUN(cwd="/path/to/flutter/project") flutter build apk

Configuration:
Create .kifdiff/config.py in your project or ~/.kifdiff/config.py globally:

```python
from config import allow_pattern, block_pattern, set_mode

# Allow additional commands
allow_pattern(r"^docker\s+(build|run|ps).*")
allow_pattern(r"^make\s+(build|test).*")

# Block specific patterns
block_pattern(r".*production.*")

# Change to allowlist mode (only allow specific patterns)
set_mode("allowlist")
```

Default Mode: Blocklist
- All commands are allowed EXCEPT those matching blocked patterns
- This gives maximum flexibility while maintaining safety

Always Blocked (regardless of mode):
- Destructive: rm -rf, dd, mkfs, format
- Privilege escalation: sudo, su
- System modification: chmod 777, chown, shutdown, reboot
- Dangerous patterns: curl | sh, eval, kill -9


Best Practices for LLMs

1. Skip Inquiry When You Have Context
If the user has already shared code, pasted file contents, or you have the information from earlier in the conversation, go straight to execution. Don't ask for information you already have.

2. Inquire Only When Necessary
Before making changes, you need to understand the codebase. But ONLY use inquiry operations (@Kif READ, @Kif TREE, @Kif FIND) when:
- You don't have the file contents
- You don't know the directory structure
- You need to find files by pattern
- You need to see implementation details not provided

3. Write Minimal Changes
Use SEARCH_AND_REPLACE instead of rewriting entire files. Only include the specific code blocks that need modification.

Exception: When the new content is drastically different from the original file, use OVERWRITE_FILE instead of multiple SEARCH_AND_REPLACE operations.

4. Use Multiple BEFORE/AFTER Blocks
When making multiple changes to the same file, use multiple BEFORE/AFTER blocks in a single SEARCH_AND_REPLACE directive instead of multiple separate directives.

5. Use Regex Wisely
When you need pattern matching, enable regex=true and remember to use replace_all=true if you want to replace all matches.

6. Be Precise with BEFORE Blocks
The BEFORE block must match exactly. If unsure about whitespace, use ignore_whitespace=true.

7. Use Absolute Paths
Never use relative paths. Always specify the full path from the project root.

8. No More FILE Directive
The @Kif FILE directive has been removed. All directives now take file paths directly as arguments.

9. Use FIND for Discovery
When you need to find files by pattern, use the new FIND directive instead of asking the user to manually locate files.

10. Use RUN for Automation
When implementing features that require running commands (tests, builds, installations), use RUN directives to automate the workflow. This allows users to execute the entire setup with a single kifdiff file.

11. Chain Commands Thoughtfully
When using multiple RUN directives, consider dependencies and error handling. For example:
- Run `npm install` before `npm test`
- Run `flutter pub get` before `flutter build`
- Check if commands succeeded before proceeding

12. ALWAYS Specify Working Directory (cwd) for Project Commands
When running project-specific commands (npm, flutter, cargo, etc.), ALWAYS specify the cwd parameter:
- BAD: `@Kif RUN npm install` (might run in wrong directory)
- GOOD: `@Kif RUN(cwd="/path/to/project") npm install`
- This is CRITICAL for LLMs working with user projects
- Default cwd is wherever kifdiff is executed, which may not be the project root

Common Workflow Examples

Scenario 1: User Provides File Contents
User Request: "Here's my home_screen.dart file: [paste code]. Add a new button."

Your Response (Direct Execution):
```text
@Kif SEARCH_AND_REPLACE /home/user/project/lib/screens/home_screen.dart
@Kif BEFORE
      body: Center(
        child: Text('Welcome'),
      ),
@Kif END_BEFORE
@Kif AFTER
      body: Center(
        child: Column(
          children: [
            Text('Welcome'),
            ElevatedButton(
              onPressed: () {},
              child: Text('Click Me'),
            ),
          ],
        ),
      ),
@Kif END_AFTER
@Kif END_SEARCH_AND_REPLACE
```

Scenario 2: Unknown Codebase
User Request: "Add a new button to the home screen"

Your Response (Inquiry First):
I need to see the current home screen implementation. Please run this inquiry:
```text
@Kif READ /home/user/project/lib/screens/home_screen.dart
```

[After receiving results, then provide execution file]

Scenario 3: Finding Files by Pattern
User Request: "Update all Python test files to use the new test framework"

Your Response (Inquiry First):
Let me find all the test files first:
```text
@Kif FIND(match_pattern=".*test.*\.py$", exclude="__pycache__|\.pyc$") /home/user/project/
```

[After receiving results, create SEARCH_AND_REPLACE directives for the found files]


Remember

DO:
- Skip inquiry if you have the necessary context
- Always wrap KifDiff content in code blocks
- Use absolute paths
- Write minimal, targeted changes
- Use multiple BEFORE/AFTER blocks for multiple changes in same file
- Use FIND to discover files by pattern
- Use regex when patterns are needed

DO NOT:
- Request file contents you already have from conversation
- Make changes without understanding the code (either from context or inquiry)
- Use relative paths
- Rewrite entire files when small changes suffice
- Forget replace_all=true when using regex to replace all matches
- Use the old @Kif FILE directive (it's been removed)

The golden rule: Only inquire when you lack necessary information. If you have all the necessary context, feel free to execute directly.
